/* ***************************************************************** */
/*                                                                   */
/* IBM Confidential                                                  */
/*                                                                   */
/* IBM Docs Source Materials                                         */
/*                                                                   */
/* (c) Copyright IBM Corporation 2012. All Rights Reserved.          */
/*                                                                   */
/* ***************************************************************** */

package com.ibm.symphony.conversion.service.common;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.HashSet;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.odftoolkit.odfdom.OdfElement;
import org.odftoolkit.odfdom.OdfFileDom;
import org.odftoolkit.odfdom.OdfName;
import org.odftoolkit.odfdom.doc.OdfDocument;
import org.odftoolkit.odfdom.pkg.OdfPackage;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;

import com.ibm.symphony.conversion.service.common.util.FileUtil;

public class OdfDomUtil
{
  private static Logger log = Logger.getLogger(OdfDomUtil.class.getName());
  public static final String ODP_MIMETYPE = "application/vnd.oasis.opendocument.presentation";
  
  public static Node cloneNode(OdfFileDom doc, Node node, boolean deep) throws Exception
  {
   
    OdfElement cloneElement;
    if( node instanceof OdfElement )
    {
      OdfElement element = (OdfElement) node;
      cloneElement = doc.newOdfElement(element.getClass());
    }
    else
    {
      cloneElement = doc.createElementNS(OdfName.newName(node.getNamespaceURI(), node.getLocalName()));
    }
   
    
    NamedNodeMap attributes = node.getAttributes();
    if (attributes != null) {
        for (int i = 0; i < attributes.getLength(); i++) {
            Node item = attributes.item(i);
            String qname = null;
            String prefix = item.getPrefix();
            if (prefix == null) {
                qname = item.getLocalName();
            } else {
                qname = prefix + ":" + item.getLocalName();
            }
            cloneElement.setAttributeNS(item.getNamespaceURI(), qname, item.getNodeValue());
        }
    }

    if (deep) {
        Node childNode = node.getFirstChild();
        while (childNode != null) {
            cloneElement.appendChild(cloneNode(doc, childNode, true));
            childNode = childNode.getNextSibling();
        }
    }

    return cloneElement;
  }
  
  /**
   * Insert a file or folder into ODF package recursively
   * @param pkg - the ODF package
   * @param filePath - the input file path, file or folder
   * @param rootPath - the root file path that is used to change filePath to relative path.
   *        The relative path is generated by cutting the rootPath part from the filePath.
   *        the rootPath can not end with file separator
   * @param relativeBase - the relative base path for the inserted file or folder in the ODF package
   *        the relativeBase can not include file separator
   * @param filter - store the file names that will not be inserted into ODF package
   */
  public static void insertToPackage(OdfPackage pkg, String filePath, String rootPath, String relativeBase, Set<String> filter)
  {
    File draft = new File(filePath);
    FileInputStream fis = null;
    try
    {
      if(draft.isFile())
      {
        fis = new FileInputStream(draft);
        pkg.insert(fis, relativeBase + filePath.substring(rootPath.length()), "application/concord");  
      }
      else
      {
        File[] files = draft.listFiles();
        for(File file : files)
        {
          if(!filter.contains(file.getName()))
          {
            insertToPackage(pkg, file.getAbsolutePath(), rootPath, relativeBase, filter);
          }
        }
      }
    }
    catch (FileNotFoundException e)
    {
      log.log(Level.WARNING,"Fail to insert file into ODF package, input file is not found", e);
    }
    catch (Exception e)
    {
      log.log(Level.WARNING,"Fail to insert file or folder into ODF package",e);
    }
    finally
    {
      if(fis != null){
        try
        {
          fis.close();
        }
        catch (IOException e)
        {
           log.log(Level.WARNING,"Fail to close input stream.", e);
        }
      }
    }
  }
  
  /**
   * Package concord draft folder into ODF package
   * @param concordFolder - temp concord draft folder
   * @param odfDoc - ODF document
   * @param picFolder - the Pictures folder in final draft folder
   */
  public static void packageConcordDraft(File tmpDraftFolder, OdfDocument odfDoc, String picFolderPath)
  {
    //copy Pictures Directory in temp concord folder to final draft folder
    String tmpDraftPath = tmpDraftFolder.getAbsolutePath();
    copyPicturesDirectoryToDraft(tmpDraftPath+ File.separator + "Pictures", picFolderPath);
    //delete Pictures in concord directory except wmf and svm and shape
    //presentation team do not want to delete the duplicate pictures now
    if(!ODP_MIMETYPE.equals(odfDoc.getMediaTypeString()))
      cleanPicturesDirectory(tmpDraftFolder);
    //insert concord folder to ODF pacakge
    Set<String> filter = new HashSet<String>(2);
    filter.add("odfdraft");
    filter.add("odfdraft.tmp");
    filter.add("content");
    insertToPackage(odfDoc.getPackage(),tmpDraftPath, tmpDraftPath, "concord", filter);
  }
  
  private static void cleanPicturesDirectory(File concordFolder)
  {
    File pictures = new File(concordFolder, "Pictures");
    Set<String> filters = new HashSet<String>();
    filters.add("wmf");
    filters.add("svm");
    filters.add("shape");
    filters.add("tif");
    filters.add("object");
    if (pictures.exists())
    {
      FileUtil.cleanDirectory(pictures, filters);
    }
  }

  private static void copyPicturesDirectoryToDraft(String sourcePath, String targetPath)
  {
    File sourcePicRoot = new File(sourcePath);
    if(!sourcePicRoot.exists())
      return;
    if(targetPath == null)
      return;
    
    File targetPicRoot = new File(targetPath);
    FileUtil.cleanDirectory(targetPicRoot);
    FileUtil.copyDirectory(sourcePicRoot,targetPicRoot);
  }
}


