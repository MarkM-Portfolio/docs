package com.ibm.concord.spreadsheet.document.model.impl;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.apache.commons.io.IOUtils;
import org.codehaus.jackson.JsonParseException;

import com.ibm.concord.draft.DraftStorageManager;
import com.ibm.concord.draft.exception.DraftDataAccessException;
import com.ibm.concord.draft.exception.DraftStorageAccessException;
import com.ibm.concord.draft.section.DraftSection;
import com.ibm.concord.draft.section.SectionDescriptor;
import com.ibm.concord.spreadsheet.SpreadsheetConfig;
import com.ibm.concord.spreadsheet.common.ConversionConstant;
import com.ibm.concord.spreadsheet.common.ReferenceParser.ParsedRefType;
import com.ibm.concord.spreadsheet.document.message.Transformer;
import com.ibm.concord.spreadsheet.document.model.NotifyEvent;
import com.ibm.concord.spreadsheet.document.model.NotifyEvent.EventSource;
import com.ibm.concord.spreadsheet.document.model.formula.Area;
import com.ibm.concord.spreadsheet.document.model.formula.FormulaUtil.FormulaToken;
import com.ibm.concord.spreadsheet.document.model.formula.FormulaUtil.ReferenceToken;
import com.ibm.concord.spreadsheet.document.model.impl.Range.RangeInfo;
import com.ibm.concord.spreadsheet.document.model.impl.io.Deserializer;
import com.ibm.concord.spreadsheet.document.model.impl.io.ModelIOFactory;
import com.ibm.concord.spreadsheet.document.model.impl.io.Serializer;
import com.ibm.concord.spreadsheet.document.model.style.StyleObject;
import com.ibm.concord.spreadsheet.document.model.util.ModelHelper.SerializableStringIdConvertor;

/**
 * Recover the sheet content for delete sheet undo event
 * Store all the deleted sheet as the sub document, and flush to "recover" sub folder as the other document
 * and instance the sub document and merge it back to main document when recover
 * @author weihuaw
 *
 */
public class RecoverManager
{
  private static final Logger LOG = Logger.getLogger(RecoverManager.class.getName());
  //the parent document
  private Document mainDoc;
  //the sub document for all the deleted sheet
  private Document recoverDoc;
  
  //the map between uuid and sheetId
  private HashMap<String, Integer> dltSheetMap;
  
  private static final List<DraftSection> recoverDraftSections;
  
  static
  {
    recoverDraftSections = new ArrayList<DraftSection>();
    recoverDraftSections.add(new DraftSection("recover_meta.js"));
    recoverDraftSections.add(new DraftSection("recover_content.js"));
    if (SpreadsheetConfig.useReferenceJS()) {
      recoverDraftSections.add(new DraftSection("recover_reference.js"));
    }
    recoverDraftSections.add(new DraftSection("recover_preserve.js"));
  }
  
  public RecoverManager(Document doc)
  {
    this.mainDoc = doc;
    dltSheetMap = new HashMap<String, Integer>();
  }
  /**
   * only for unit test
   * @return
   */
  @Deprecated
  public Document getRecoverDoc()
  {
    return recoverDoc;
  }
  
  /**
   * back up the will be deleted sheet to the recover document before delete it from the main document
   * @param uuid the unique id for this delete sheet action, generated by client
   * @param sheetName   the will be delete sheet name
   * @throws Exception 
   */
  public void backupSheet(String uuid, String sheetName) throws Exception
  {
    if(null == uuid) 
      return;
    if(recoverDoc == null)
    {
      //the recover doc is in draft storage, need to deserialize
      deserialize();
//      recoverDoc = new Document();
    }
    Sheet sheet = mainDoc.getSheetByName(sheetName);
    if(sheet == null)
    {
      LOG.log(Level.WARNING,"can not backup sheet {0} when delete sheet because it does not exist", sheetName);
      return;
    }
    int sheetId = sheet.getId();
    dltSheetMap.put(uuid, sheetId);
    recoverDoc.backupSheet(sheet);
    sheet.setUUId(uuid);
    recoverDoc.idManager.backupSheet(sheet, mainDoc.idManager);
    recoverDoc.getRangeList().backup(sheetId, mainDoc.getRangeList());
    recoverDoc.getPreserveManager().backup(sheetId, mainDoc.getPreserveManager());
    recoverDoc.getAreaManager().backup(sheetId, mainDoc.getAreaManager());
    recoverDoc.backupRulesObjects(sheetId, mainDoc);
//    recoverDoc.getReferenceList().backup(sheetId, mainDoc.getReferenceList());
  }
  
  /**
   * Recover the sheet from recover manager which is stored in recover document
   * @throws Exception 
   */
  public Sheet recoverSheet(String uuid, String sheetName, int sheetIndex) throws Exception
  {
    if(recoverDoc == null)
    {
      //the recover doc is in draft storage, need to deserialize
      deserialize();
    }
    Integer sheetId = dltSheetMap.get(uuid);
    if(sheetId == null)
    {
      LOG.log(Level.WARNING, "the sheet with uuid {0} does not exist in recover document", uuid);
      return mainDoc.insertSheet(sheetName, sheetIndex, null);
    }
    Sheet sheet = recoverDoc.getSheetById(sheetId);
    //the sheetName might different with that in recover manager
    String oldSheetName = sheet.getSheetName();
    mainDoc.recoverSheet(sheet, sheetName, sheetIndex, recoverDoc);
    mainDoc.idManager.recoverSheet(sheet, oldSheetName, recoverDoc.idManager);
    mainDoc.getRangeList().recoverRanges4Sheet(sheetId, recoverDoc.getRangeList());
    mainDoc.getAreaManager().recoverRanges4Sheet(sheetId, recoverDoc.getAreaManager());
//    mainDoc.getReferenceList().recoverRanges4Sheet(sheetId, recoverDoc.getReferenceList());
    mainDoc.getPreserveManager().recoverSheet(sheetId, recoverDoc.getPreserveManager());
    mainDoc.recoverOuterRefFromUnNameRange(sheet);
    mainDoc.recoverRulesObjects(sheetId, recoverDoc);
    //broadcast set sheet name event
    if(!oldSheetName.equals(sheetName))
    {
      RangeInfo refValue = new RangeInfo(sheet.getId(), 1, 1, ConversionConstant.MAX_ROW_NUM, ConversionConstant.MAX_COL_NUM, ParsedRefType.RANGE);
      EventSource source = new EventSource(NotifyEvent.ACTION.SET, NotifyEvent.TYPE.SHEET, refValue);
      NotifyEvent e = new NotifyEvent(NotifyEvent.CATEGORY.DATACHANGE, source);
      mainDoc.insertEvent(e);
      mainDoc.broadcastEventList();
    }
    return sheet;
  }
  
  /**
   * Deserialize the recover document from the recover doc input stream
   * @param recoverInStreams 
   * @throws IOException 
   * @throws JsonParseException 
   */
  public void deserialize() throws Exception
  {
    if (ModelIOFactory.HAS_STORAGE_MANAGER)
    {
      Deserializer deserializer = Transformer.getModelIOFactory().createDeserializer();
      //set deserializer to the recover status
      deserializer.setRecoverDeserializer(true);
      deserializer.setMainDoc(mainDoc);
      DraftStorageManager dsm = DraftStorageManager.getDraftStorageManager(false);
      recoverDoc = (Document) dsm.getDraftMediaAsObject(mainDoc.getDraftDescriptor(), deserializer);
    }
    else
    {
      Deserializer deserializer = ModelIOFactory.getInstance().createDeserializer();
      //set deserializer to the recover status
      deserializer.setRecoverDeserializer(true);
      deserializer.setMainDoc(mainDoc);
      if (mainDoc.getDraftDir() == null)
      {
        LOG.warning("no DraftStorageManager and no draft URI set, cannot recover, skip.");
        return;
      }
      
      InputStream[] ins = new InputStream[4];
      try
      {
        deserializer.setDraftDir(mainDoc.getDraftDir());
        for (int i = 0; i < recoverDraftSections.size(); i++)
        {
          DraftSection ds = recoverDraftSections.get(i);
          File file = new File(mainDoc.getDraftDir(), ds.getSectionLabel());
          if (file.exists())
          {
            ins[i] = new FileInputStream(file);
          }
        }
        
        deserializer.setInputStreams(ins);
        
        recoverDoc = deserializer.deserialize();
      }
      finally
      {
        for (int i = 0; i < ins.length; i++)
        {
          IOUtils.closeQuietly(ins[i]);
        }
      }
    }
      

    int size = recoverDoc.sheets.size();
    if (size == 0)
    {
      LOG.log(Level.FINER, "There is no sheet when deserialize the recover doc");
      return;
    }
    for (int i = 0; i < size; i++)
    {
      Sheet sheet = recoverDoc.sheets.get(i);
      String uuid = sheet.getUUId();
      if (uuid == null)
      {
        LOG.log(Level.WARNING, "The sheet in recover doc should contain uuid");
        continue;
      }
      dltSheetMap.put(uuid, sheet.getId());
    }
  }
  /**
   * Serialize the recover document which contain the deleted sheet
   * 
   * @param outStreams the outputStream for recover doc
   * @throws IOException 
   * @throws DraftDataAccessException 
   * @throws DraftStorageAccessException 
   * @return true if recover document has content
   */
  public void serialize(List<StyleObject> styleList) throws Exception
  {
    if (recoverDoc == null)
    {
      // recover doc is null, means it has not been instanced or not exist
      // if not exist, should not serialize the unnamed range with "RECREF" usage in main doc
      // recover meta file path
      String recMeta;
      if (ModelIOFactory.HAS_STORAGE_MANAGER)
      {
        DraftStorageManager dsm = DraftStorageManager.getDraftStorageManager(false);
        SectionDescriptor sd = dsm.getSectionDescriptor(mainDoc.getDraftDescriptor(), recoverDraftSections.get(0));
        recMeta = sd.getSectionUri();
      }
      else
      {
        if (mainDoc.getDraftDir() == null)
        {
          LOG.warning("no draft storage manager found and no draft URI set, cannot serialize recover document.");
          return;
        }

        recMeta = new File(mainDoc.getDraftDir(), recoverDraftSections.get(0).getSectionLabel()).getAbsolutePath();
      }
      File recoverFile = new File(recMeta);
      if (!recoverFile.exists())
        mainDoc.getIdConvertor().cacheStrId("");// make the strIdCache not null
      return;
    }
    // else the recover document is not null

    setParent(recoverDoc);
    // serialize doc
    if (ModelIOFactory.HAS_STORAGE_MANAGER)
    {
      Serializer serializer = Transformer.getModelIOFactory().createSerializer();
      serializer.setRecoverSerializer(true);
      serializer.setMainDoc(mainDoc);
      serializer.setStyleList(styleList);
      DraftStorageManager.getDraftStorageManager(false).storeDraft(mainDoc.getDraftDescriptor(), recoverDoc, serializer,
          recoverDraftSections);
    }
    else
    {
      OutputStream[] outs = new OutputStream[4];
      try
      {
        Serializer serializer = ModelIOFactory.getInstance().createSerializer();
        serializer.setRecoverSerializer(true);
        serializer.setMainDoc(mainDoc);
        serializer.setStyleList(styleList);
        for (int i = 0; i < outs.length; i++)
        {
          File file = new File(mainDoc.getDraftDir(), recoverDraftSections.get(i).getSectionLabel());
          outs[i] = new FileOutputStream(file);
        }
        // no reference.js stream. need skip
        if (SpreadsheetConfig.useReferenceJS()) {
          outs[3] = outs[2];
          outs[2] = null;
        }
        serializer.setOutStreams(outs);
        serializer.serialize(recoverDoc);
      }
      finally
      {
        for (int i = 0; i < outs.length; i++)
        {
          IOUtils.closeQuietly(outs[i]);
        }
      }
    }

    SerializableStringIdConvertor conv = recoverDoc.getIdConvertor();
    // the initial id for main document should start from the recover document
    mainDoc.getIdConvertor().setInitRowCount(conv.getRowCount());
    mainDoc.getIdConvertor().setInitColumnCount(conv.getColumnCount());
    mainDoc.getIdConvertor().setInitStyleCount(conv.getStyleCount());
    mainDoc.getIdConvertor().setInitSheetId(conv.getMaxSheetId());
    // set parent of each model back to main document
    // because some reference or ranges address should be #REF!
    setParent(mainDoc);
  }
  
  //Set parent for each model
  public void setParent(final Document parentDoc)
  {
    // 1. sheet
    List<Sheet> sheetList = recoverDoc.getSheets();
    int size = sheetList.size();
    if(size == 0)
      return;
    for(int i=0; i < size; i++)
    {
      Sheet sheet = sheetList.get(i);
      sheet.parent = recoverDoc;
      List<Row> rows = sheet.getRows();
      for (int j = 0; j < rows.size(); j++)
      {
        Row row = rows.get(j);
        // set parent doc for reference token which is in the parent doc
        // so that the references in the parent doc can get the correct address value
        // and the references referred by parent doc but not exist in the sheets of parent doc can also return the right address
        // rather than "#REF!" as sheet name, because this value should be recovered correctly when recover sheet
        // and when serialize such doc, this reference can be changed to an unnamedrange with RECREF type in mainDoc
        List<ValueCell> vCells = row.getValueCells();
        for (int m = 0; m < vCells.size(); m++)
        {
          ValueCell vc = vCells.get(m);
          FormulaCell cell = vc.getFormulaCell();
          if(cell != null)
          {
            for(int n = 0; n < cell.getTokenList().size(); n++)
            {
              FormulaToken token = cell.getTokenList().get(n);
              if(token instanceof ReferenceToken)
              {
                ReferenceToken rToken = (ReferenceToken)token;
                Area area = rToken.getArea();
                if(area != null && parentDoc.getSheetById(area.getSheetId()) != null)
                  rToken.setDocument(parentDoc);
              }
            }
          }
        }
      }
    }
    // 2. unname range -- String Id
    recoverDoc.getRangeList().setParent(parentDoc);
    // 3. reference -- Integer Id
//    recoverDoc.getAreaManager().setParent(parentDoc);
    // 4. preserve range
    recoverDoc.getPreserveManager().getRangeList().setParent(parentDoc);
    recoverDoc.getPreserveManager().getStyleRangeList().setParent(parentDoc);
  }
  
  //only used for unit test
  @Deprecated
  public void setRecoverDoc(Document d)
  {
    // TODO Auto-generated method stub
    recoverDoc = d;
  }
}
