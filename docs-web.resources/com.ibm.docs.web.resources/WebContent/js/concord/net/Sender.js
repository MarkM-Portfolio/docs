/* ***************************************************************** */
/*                                                                   */
/* IBM Confidential                                                  */
/*                                                                   */
/* IBM Docs Source Materials                                         */
/*                                                                   */
/* (c) Copyright IBM Corporation 2012. All Rights Reserved.          */
/*                                                                   */
/* U.S. Government Users Restricted Rights: Use, duplication or      */
/* disclosure restricted by GSA ADP Schedule Contract with IBM Corp. */
/*                                                                   */
/* ***************************************************************** */

/**
 * manage message sending request
 * content change message will be sent by this Sender in co-editing mode
 * control message will be sent no matter it's single or co-editing mode
 *@author: gaowwei@cn.ibm.com
 */
dojo.provide("concord.net.Sender");

dojo.require("concord.net.SessionProxy");

concord.net.Sender = new function()
{
	this._deferred = null;
	this._sending = false;
	this._session = null;
	this._stopped = true;
	
	/**
	 * start message sender
	 * @param	session
	 * 			session object itself
	 * @param	callback
	 * 			ignore this parameter
	 */
	this.start = function(session, callback)
	{
		this._session = session;
		this._sending = false;
		this._deferred = null;
		this._stopped = false;
	};
	
	/**
	 * stop message sender
	 */
	this.stop = function(isCancel)
	{
        if (this._deferred != null) {
        	// there is a message sending request ongoing,
        	// cancel it, then rollback the data
            if (isCancel == null || isCancel == true) {
		    this._deferred.cancel();
	    }
            this._rollback(JSON.parse(this._deferred.ioArgs.args.postData));
            this._deferred = null;
        }
        this._sending = false;
        this._stopped = true;
	};
	
	/**
	 * send message directly
	 * @param	ctlMsgList
	 * 			if null, then will send messages from waiting list
	 * 			else, will send out control message from parameter directly
	 * 			control message has no quality of service
	 * 			errorHandler
	 * 			if null,send as normal 
	 * 			else, will handle the error by the sender. 
	 */
	this.send = function(ctlMsgList,errorHandler)
	{
		if (this._stopped)
		{
			return;
		}

		if ((this._session.waitingList.length == 0) && !ctlMsgList)
		{
			return;
		}
		
		var data = new Object();
		if (ctlMsgList)
		{
			// just for control message
			data.msgList = ctlMsgList;
			data.count = ctlMsgList.length;
			// no quality of service, no rollback, no error handling
			if(errorHandler)
				concord.net.SessionProxy.post(this._session.url + "/msg", data, null, dojo.hitch(this, errorHandler), false);
			else 
				concord.net.SessionProxy.post(this._session.url + "/msg", data, null, null, false);
		}
		else {
			if (this._sending == true)
			{
				// only allow one messaging request ongoing
				return;
			}
			
			if (this._hasReconnect) {
				if (!this._reconnectTime)
					this._reconnectTime = new Date();
				else {
					var duration = ((new Date()) - this._reconnectTime)/1000;
					
					this._hasReconnect = false;
					this._reconnectTime = null;
					
//					if (duration > g_hbTimeout && duration < (g_hbTimeout * 2)) {
						// Go into here means the msg sent in hearbeat can not be successfully handled by server
						// (such as message generated by presentation which is too large with bad network situation)
						// While reconnect to server is always successful.
						// Then we need stop send such message by reload
					if (!this.nls)
					{
						dojo.requireLocalization("concord.scenes","Scene");
						this.nls = dojo.i18n.getLocalization("concord.scenes","Scene");
					}
					this._session.makeOffline(this.nls.offlineReasonForServerUnacceptedMsg);
					return;
//					}
				}
			} else
				this._reconnectTime = null;

			this._sending = true;
			data.msgList = this._session.waitingList;
			data.count = this._session.waitingList.length;
			// append to sendout message list
			this._session.sendoutList = this._session.sendoutList.concat(this._session.waitingList);
			this._session.waitingList = [];
			this._deferred = concord.net.SessionProxy.post(this._session.url + "/msg", data, dojo.hitch(this, this._successHdl), dojo.hitch(this, this._errorHdl), false);
		}
	};
	
	this._successHdl = function(data)
	{
		this._hasReconnect = false;
		this._deferred = null;
		this._sending = false;
		this.send();
	};
	
	this._errorHdl = function(response, ioArgs)
	{
		// Get status code before call method this.stop(), because after call that method, the variable 'ioArgs.xhr.status' is disposed.
		var status = (response.dojoType != "timeout" && ioArgs.xhr != null) ? ioArgs.xhr.status : -1;
		
		// stop myself
		// in stop method, the request data will be rollbacked
		this.stop(false);

		// If the returned HTTP status is 403 and response.error_code is 3100, this editing is kicked out.
		try
		{
			// Error code 3100(DocumentSessionException.ERR_PT_KICKOUT_DUP) indicates the participant 
			// is kicked out, because the same user joined the document session from different browser.
			if (status === 403)
			{
				var respJson = dojo.fromJson(response.responseText);
				if (respJson && respJson.error_code === 3100)
				{
					this._session.makeKickedOut();
					return;
				}
			}
		}
		catch (e)
		{
			console.log("Error happens when parse the sending message request's result: ", e);
		}
		
		// call session to reconnect
		this._session.reconnect();
		this._hasReconnect = true;
	};
	
	this._rollback = function(data)
	{
		// remove last "count" from sendoutList
		// and move to waitingList
		var count = data.count;
		var length = this._session.sendoutList.length;
		var list1 = this._session.sendoutList.slice(0, length - count);
		var list2 = this._session.sendoutList.slice(length - count, length);
		this._session.sendoutList = list1;
		this._session.waitingList = list2.concat(this._session.waitingList);		
	};
}();

