/* ***************************************************************** */
/*                                                                   */
/* HCL Confidential                                                  */
/*                                                                   */
/* OCO Source Materials                                              */
/*                                                                   */
/* Copyright HCL Technologies Limited 2010, 2022                     */
/*                                                                   */
/* The source code for this program is not published or otherwise    */
/* divested of its trade secrets, irrespective of what has been      */
/* deposited with the U.S. Copyright Office.                         */
/*                                                                   */
/* ***************************************************************** */

/**
 * manage heart beat request
 * 1. report to server the client is still alive
 * 2. report to server the client's current state
 * 2. send content change messages if in single mode
 *@author: gaowwei@cn.ibm.com
 */
dojo.provide("concord.net.Beater");

dojo.require("concord.net.SessionProxy");

concord.net.Beater = new function()
{
	this._hbDeferred = null;
	this._hbTimer = null;
	this._session = null;
	this._callback = null;
	this._stopped = true;

	this._reconnectTime = null;
	/**
	 * start heart beat service
	 * @param	session
	 * 			session object itself
	 * @param	callback
	 * 			callback function when heart beat successfully
	 */
	this.start = function(session, callback)
	{
		this._session = session;
		this._callback = callback;
		this._hbDeferred = null;
		this._stopped = false;
		this._hbTimer = window.setTimeout(dojo.hitch(this, this.beat, false), 1000);
	};

	/**
	 * stop heart beat service
	 */
	this.stop = function(isCancel)
	{
		if (this._stopped)
			return;

		if (this._hbDeferred != null) {
			// there is a beat request ongoing,
			// cancel it, then rollback the data
			if (isCancel == null || isCancel == true)
			{
				this._hbDeferred.cancel();
			}
			this._rollback(JSON.parse(this._hbDeferred.ioArgs.args.postData));
			this._hbDeferred = null;
		}

		if (this._hbTimer != null)
		{
			try {
				window.clearTimeout(this._hbTimer);
			}
			catch (e)
			{

			}
			this._hbTimer = null;
		}

		this._stopped = true;
	};

	this.beat = function(leaving, bSync, saving)
	{
		if (this._stopped)
		{
			return;
		}

		// stop previous beat request, if any
		this.stop();
		this._stopped = false;

		if (this._hasReconnect) {
			if (!this._reconnectTime)
				this._reconnectTime = new Date();
			else {
				var duration = ((new Date()) - this._reconnectTime)/1000;
				
				this._hasReconnect = false;
				this._reconnectTime = null;
				
				// Go into here means the msg sent in hearbeat can not be successfully handled by server
				// (such as message generated by presentation which is too large with bad network situation)
				// While reconnect to server is always successful.
				// Then we need stop send such message by reload
				if (!this.nls)
				{
					dojo.requireLocalization("concord.scenes","Scene");
					this.nls = dojo.i18n.getLocalization("concord.scenes","Scene");
				}
				this._session.makeOffline(this.nls.offlineReasonForServerUnacceptedMsg);
				return;
			}
		} else
			this._reconnectTime = null;
		
		var data = new Object();
		data.seq = this._session.getCurrentSeq();

		if (this._session.isSingleMode()) {
			// in single user mode, appending messages will be sent via beat service
			if (this._session.waitingList != undefined && this._session.waitingList.length != 0) {
				data.msgList = this._session.waitingList;
				// put message in sendout list, waiting for verify
				this._session.sendoutList = this._session.waitingList;
				this._session.waitingList = [];
			}
		}

		var url = null;
		if (saving) {
			url = this._session.url + "/hb?save=true";
		} else {
			url = this._session.url + "/hb?save=false";
		}

		var sync = false;
		if (typeof bSync != "undefined")
			sync = bSync;

		if (leaving) {
			// combine SAVE and LEAVE request
			url = url + "&leave=true";
			var leaveData = this._session.getLeaveData();
			if(leaveData!=null)
			{
			    data.leavedata = leaveData;
			}
			// the request need to be synchronized, else browser will close the request immediately
			// which will cause the server fails reading the request body
			
			// Fix for PMR DOCS-143 and DOCS-145
			// In the latest version of Chrome v80 chrome has removed support for any synchronous calls from the unload or close events of tab or browser. Ref link https://www.chromestatus.com/feature/4664843055398912. 
			// So for chrome making the ajax call asynchronous
			sync = !(dojo.isChrome >= 80); // set sync = false if chrome >= 80
		}

		this._hbDeferred = concord.net.SessionProxy.post(url, data, dojo.hitch(this, this._successHdl), dojo.hitch(this, this._errorHdl), sync);
		if (sync == true)
		{
			// has already been processed if in sync mode
			this._hbDeferred = null;
		}
	};

	this._intervalBeat = function()
	{
		this._hbTimer = null;
		this.beat();		
	};

	this._successHdl = function(data)
	{
		// start another beat in timer
		this._hasReconnect = false;
		this._hbDeferred = null;
		this._hbTimer = window.setTimeout(dojo.hitch(this, this._intervalBeat), g_hbInterval);

		this._callback(data);
	};

	this._errorHdl = function(response, ioArgs)
	{
		// Get status code before call method this.stop(), because after call that method, the variable 'ioArgs.xhr.status' is disposed.
		var status = (response.dojoType != "timeout" && ioArgs.xhr != null) ? ioArgs.xhr.status : -1;
		
		// stop myself
		// in stop method, the request data will be rollbacked
		this.stop(false);

		if (ioArgs.args.sync == true)
		{
			// sync mode, hbDeferred is null, so rollback here
			this._rollback(JSON.parse(ioArgs.args.postData));
		}

		// If the returned HTTP status is 403 and response.error_code is 3100, this editing is kicked out.
		try
		{
			// Error code 3100(DocumentSessionException.ERR_PT_KICKOUT_DUP) indicates the participant 
			// is kicked out, because the same user joined the document session from different browser.
			if (status === 403)
			{
				var respJson = dojo.fromJson(response.responseText);
				if (respJson && respJson.error_code === 3100)
				{
					this._session.makeKickedOut();
					return;
				}	
			}
		}
		catch (e)
		{
			console.log("Error happens when parse the heart beat request's result: ", e);
		}
		
		// call session to reconnect
		this._session.reconnect();
		this._hasReconnect = true;
	};

	this._rollback = function(data)
	{
		if (data.msgList != undefined) {
			// waiting = sendout + waiting
			// sendout = empty
			var newList = this._session.sendoutList.concat(this._session.waitingList);
			this._session.waitingList = newList;
			this._session.sendoutList = [];
		}
	};
}();

