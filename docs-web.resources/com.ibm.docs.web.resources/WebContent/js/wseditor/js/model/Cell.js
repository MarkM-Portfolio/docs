/* ***************************************************************** */
/*                                                                   */
/* IBM Confidential                                                  */
/*                                                                   */
/* IBM Docs Source Materials                                         */
/*                                                                   */
/* (c) Copyright IBM Corporation 2012. All Rights Reserved.          */
/*                                                                   */
/* U.S. Government Users Restricted Rights: Use, duplication or      */
/* disclosure restricted by GSA ADP Schedule Contract with IBM Corp. */
/*                                                                   */
/* ***************************************************************** */

/****************************************************/
/* created by LinXin, linxinbj@cn.ibm.com           */
/*   1/27/2011                                      */
/* Cell Model									    */
/****************************************************/
dojo.provide("websheet.model.Cell");
dojo.require("websheet.Constant");
dojo.require("websheet.i18n.Number");
dojo.require("websheet.Helper");
dojo.require("websheet.parse.FormulaParseHelper");
dojo.require("websheet.functions.IObject");
dojo.require("websheet.model._cell");
dojo.declare("websheet.model.Cell",[websheet.functions.Cell, websheet.model._cell], { // websheet.functions.Cell should be the first one in the inherited list

	_rawValue:null,					//cell raw value

	_calculatedValue:null,		        //if cell is a formula,then store its calculate value
	_error:null,					//cell error information,like recursive error,#VALUE! and so on
										//set to null if it has no error
	_type: null,	 // cell type, an integer

	_errProp:websheet.Constant.CellErrProp.DEFAULT,
	
	//variable when loading document, which are useless after loading
	isParsed:false,								//check if the cell has been parsed

	//in fact,_updateRefTokens and _tokenArray store the same content with different structures
	_updateRefTokens:null,					//updateRefToken map of the formula cell, these tokens are not on the token tree
								//key is reference id, value is the array of token which calculate value is this reference
	_tokenArray:null,			//array of cell/range type tokens which is on the token tree
	ValueCellType: websheet.Constant.ValueCellType,
	// _bNumber:false,								// _bNumber is @deprecated after cell type is used  
//	_tokens:null,								//token tree
//	_tokenJson:null,				//syntax tree with priority can be generated by Mobile Native parser framework
//	_bUpdateFormula:false,						//the flag indicates whether regenerate format string from the token list for formula cell or not
//	_userId:null,								//user id
//	_format: null, 				//format obj for formatting formula cell that doesn't have format style
//	isCR:false,									//if the cell has been checked the recursive relationship
	//_isUnCalc, fi are the two members for formula cells
//	_bCheckCR:false,						//true if the cell should be checked as recursive cells 
//	_isDirty:false,								//check if the cell's value should be recalculated
//	_hasLink:false,
//	link:null,
//	_showValue:null,			// cached show value for either number cell or number format cell that is locale sensitive
	
	/**
	 * constructor
	 */
	constructor:function(parent,
			id,
			repeatednum,
			value,
			calculatedValue,
			styleId,
			link,
			cellType,
			cellRef,
			tokenJson){
		this._updateRefTokens = {};
		this._rawValue = "";
		this._calculatedValue = "";
		this._tokenArray = [];
		if (tokenJson) this._tokenJson = tokenJson;
		
		if (cellType != null) {
			this._type = cellType;
		} else {
			if (value != null) {
				// determine cell type by myself
				this._type = this._doc._mhelper.getCellType(value, calculatedValue);
				// fix values
				if (this.isFormula()) {
					calculatedValue = this._doc._mhelper.fixValueByType(calculatedValue, this._type);
				} else {
					value = this._doc._mhelper.fixValueByType(value, this._type);
				}
			} else {
				// empty value makes raw value remains "", take string as its initial type
				this._type = this.ValueCellType.STRING << 3;	
			}
		}
		
		if (arguments.length == 2){
			this.isParsed = true;
			return;
		}
		
		if(undefined != value){
			this._rawValue = value;
			if (this._doc.isLoading)
				++ this._doc._numOfLoadedCells;
		}
		
		var bFormula = this.isFormula();
		
		if (calculatedValue == null || !bFormula) {
			// no cv provided, or is not formula
			this._calculatedValue = this._rawValue;
		} else {
			this._calculatedValue = calculatedValue;
		}
		
		if(undefined != link){
		    this.setLink(link, true);
		}
		
		if (this._calculatedValue != null && (this._type >> 3) == this.ValueCellType.STRING) {
			// provided string cv,
			this._calculatedValue = this.escapeSingleQuote(this._calculatedValue);
		}
		
		//_parse the raw value
		if(bFormula) {
			this._uniqueId = this._parent._parent._id + "." + this._id + this._parent._id;
			this._doc._calcManager.updateFormulaCell(this,true);//bFormula=true
			this.setReferences(cellRef);
			if(!this._doc.isLoading){
				this._needPartial = true;
			}
		} else {
			this.isParsed = true;
			// set error if it is type error
			if (this._type >> 3 == this.ValueCellType.ERROR) {
				this._error = this._doc._mhelper.toErrCode(this._rawValue);
			}
		}
	},

	/////////////////// websheet.functions.Cell  //////////////////////////////////////
	/*string*/getSheetName: function() {
		return this._parent._parent.getSheetName();
	},
	
	/*string*/getSheetId: function() {
		return this._parent._parent.getId();
	},
	
	/*string*/getValue: function() {
		// it is safe to get raw value here
		return this._rawValue;
//		return this.getRawValue();
	},
	
	getComputeValue: function() {
		// it is safe to get calculated value here because the cell would be checked in FormulaBase prior to get the cell's calculated value
		return this._calculatedValue;
//		return this.getCalculatedValue();
	},
	
	/**
	 * check if the cell is the formula cell
	 */
	/*boolean*/isFormula:function()
	{
		return (this._type & this.ValueCellType.FORMULA_TYPE_MASK) != 0;
	},
	
	/**
	 * the cell is one number cell?
	 */
	/*boolean*/isNumber:function(){
		return this._rawValue != null && ((this._type >> 3) == this.ValueCellType.NUMBER);
	},
	
	/**
	 * is boolean cell?
	 */
	/* boolean */ isBoolean: function() {
		return (this._type >> 3) == this.ValueCellType.BOOLEAN;
	},
	
	/**
	 * is string cell?
	 */
	/* boolean */ isString: function() {
		return (this._type >> 3) == this.ValueCellType.STRING;
	},
	
	/* boolean */ isError: function() {
		return this._error != null && (this._type >> 3) == this.ValueCellType.ERROR;
	},

	/* boolean */ isUnknown: function() {
		return (this._type >> 3) == this.ValueCellType.UNKNOWN;
	},

	/**
	 * return cell's error.
	 */
	/*websheet.Constant.ErrorCode*/getError:function(){
		return this._error;
	},

	/**
	 * get cell's error prop
	 */
	/*errProp*/getErrProp:function(){
		return this._errProp;
	},

	/**
	 * set cell's error,e.g recursive error,#VALUE!,and so on being defined in the websheet.Constant.ERRORCODE.
	 */
	/*void*/setError:function(error){
		this._error = error;
		// set cell type to formula and error
		this._type = (this.ValueCellType.ERROR << 3) | (this._type & this.ValueCellType.FORMULA_TYPE_MASK); 
		if(this._error)
		{
			this.setCalculatedValue(this._error.message);
		}
	},

	/*void*/setComputeValue: function(value) {
		this.setCalculatedValue(value);
	},

	/**
	 * push the range/cell token to the current cell(this cell must be a formula cell)
	 * and set up the relationship between reference and cell
	 * return the unique reference id
	 */
	pushRef:function(token, bInTokenTree)
	{
		if(token && (token.getTokenType() == websheet.parse.tokenType.RANGEREF_TOKEN
				|| token.getTokenType() == websheet.parse.tokenType.NAME))
		{
			var area = token.getValue();
			if(this._needPartial && area.setNeedPartial)//the area might be undefined name which do not have setNeedPartial method
				area.setNeedPartial(true);
			
			if(bInTokenTree){
				token._arrayIndex = this._tokenArray.length;
				this._tokenArray.push(token);
			} else {
				//1.area is already exist in document area manager
				// and area has relation with this cell by addListner
				
				//2.add ref to itself reference list
				var id = area.getId().toLowerCase();
				if(!this._updateRefTokens[id])
				{
					this._updateRefTokens[id] = [];
				}
				var list = this._updateRefTokens[id];
				// bUnique means only push the unique token for the same reference
				list.push(token);
			}
		}
	}, 
	
	/*void*/deleteRef:function(/*websheet.parse.UpdateRefToken*/token) {
		if(token && (token.getTokenType() == websheet.parse.tokenType.RANGEREF_TOKEN
				|| token.getTokenType() == websheet.parse.tokenType.NAME))
		{
			var area = token.getValue();
			var id = area.getId().toLowerCase();
			var list = this._updateRefTokens[id];
			if(list && list.length > 0)
			{
				var areaMgr = this._doc.getAreaManager();
				var bContain = area.hasListener(this);
				//if ref related cell does not contain this cell, then should not delete ref count
				if(bContain)
					areaMgr.endListeningArea(area, this);
				for(var i=0;i<list.length; i++)
				{
					if(list[i] == token)
					{
						list.splice(i,1);
						break;
					}
				}
			}
		}
	},

	updateCellForCut:function(sheetDelta){
		if(this._dirtyCut){
			var changedToken = [];
			if(sheetDelta){
				var length = this._tokenArray.length;
				var sheetName = this._getSheet()._name;
				for(var i = 0; i < length; i++){
					var token = this._tokenArray[i];
					if((token._refMask & websheet.Constant.RefAddressType.SHEET) == 0 && sheetName == token.getValue().getSheetName()){
						token._refMask |= websheet.Constant.RefAddressType.SHEET;
						changedToken.push(token);
					}
				}
			}
			this._doc.addCutUpdateCell(this._uniqueId,{v:this.getRawValue(),tarr:this.serializeTokenArray(true)});
			delete this._dirtyCut;
			var cLen = changedToken.length;
			for(var j = 0; j < cLen ; j++){
				var token = changedToken[j];
				token._refMask ^=  websheet.Constant.RefAddressType.SHEET;
			}
		}
		else if(sheetDelta){
			var length = this._tokenArray.length;
			var changedToken = [];
			for(var i = 0; i < length; i++){
				var token = this._tokenArray[i];
				if((token._refMask & websheet.Constant.RefAddressType.SHEET) == 0){
					token._refMask |= websheet.Constant.RefAddressType.SHEET;
					changedToken.push(token);
				}
			}
			var cLen = changedToken.length;
			if(cLen > 0){
				this._bUpdateFormula = true;
				this._doc.addCutUpdateCell(this._uniqueId,{v:this.getRawValue(),tarr:this.serializeTokenArray(true)});
				for(var j = 0; j < cLen ; j++){
					var token = changedToken[j];
					token._refMask ^=  websheet.Constant.RefAddressType.SHEET;
				}
			}
		}
	},
	
	/**
	 * clear the reference map of the formula cell
	 */
	/*void*/clearRefs:function()
	{
		//remove refCount for each ref, if refCount ==0, delete it
		var areaMgr = this._doc.getAreaManager();
		for(var id in this._updateRefTokens)
		{
			var list = this._updateRefTokens[id];
			var count = list.length;
			for(var i=0;i<count;i++)
			{
				var token = list[i];
				var area = token.getValue();
				var bContain = area.hasListener(this);
				//if ref related cell does not contain this cell, then should not delete ref count
				if(bContain)
					areaMgr.endListeningArea(area, this);
			}
			delete this._updateRefTokens[id];
		}
		
		for(var i = 0; i < this._tokenArray.length; i++) {
			var token = this._tokenArray[i];
			var area = token.getValue();
			var bContain = area.hasListener(this);
			if(bContain)
				areaMgr.endListeningArea(area, this);
		}
		
		this._tokenArray = [];
	},

	/**
	 * clear cell's token tree
	 */
	/*void*/clearCellToken:function(tokens){
		delete this._tokens;
	},
	/////////////////// End of websheet.functions.Cell ////////////////////////////////
	
	/*
	 * Mixin all properties and the selected functions of given value cell or style cell object
	 * to this value cell object in order to improve mixin performance.
	 * When add one new property, please add it into this function.
	 * 
	 * @param	cell 		value cell or style cell
	 * @return				one mixed cell object
	 */
	/*websheet.model.Cell*/mixin: function(/*websheet.model._cell*/cell) {
		if (!cell) return this;
		
		//don't mix the repeatednum of coverinfo to mixed cell!!!
		if (!cell._colSpan && cell._repeatednum !== undefined) 
			this._repeatednum = cell._repeatednum;
		
		if(cell._styleId) {
			// all properties of style cell should be listed here
			this._styleId = cell._styleId;
			// the function that mixed cell object will access
//			this["getStyleId"] = cell["getStyleId"]; // function
		}else if(cell._colSpan || cell._rowSpan){
			// all properties of coverinfo should be listed here
			this._colSpan = cell._colSpan;
			this._rowSpan = cell._rowSpan;
		}
		
		return this;
	},
	
	escapeSingleQuote: function(value)
	{
		if( typeof value == "string" && value.length >0 && value.charAt(0) == "'")
			return value.substring(1);
		else 
			return value;
	},
	
	/*boolean*/hasLink: function(){
		return this._hasLink != undefined ? this._hasLink : false;
	},
	
	/*boolean*/hasURL: function(){
		return (this.link != undefined ) || (this._hasURL != undefined ? this._hasURL : false);
	},
	
	//Link value is from hyperlink formula.
	setTmpLink: function(link){
		this.tmpLink = link;
		delete this._hasURL;
		this._hasLink = true;
		if(websheet.Helper.isValidURL(link))
			this._hasURL = true;
	},
	
	isLinkFormula: function()
	{
		return this.link == null;
	},
	
	/*set link value, and set _hasLink value based on parse result*/
	// @param bLoaded			true if the link is from server json file
	/*void*/setLink: function(link, bLoaded){
		delete this._hasLink;
		if(!(typeof link=="string")){
			delete this.link;
			return;
		}
		this.link = link;		
		if(this.link === "" ){
			delete this.link;
			if(this.tmpLink != undefined)
				this._hasLink = true;
			return;
		}
		if(link){
			// won't valiate the url if bLoaded is true
			// because currently there exists different validation between
			// concord and Excel
			if(bLoaded){
				this._hasLink = true;
			}else{
				if(websheet.Helper.isValidURL(link)){
					this._hasLink = true;
				}else{
					if(! this.isFormula())
						delete this.link;
				}
			}
		}
	},
	
	/*string*/getLink:function(bNotLinkFormula){
		if(bNotLinkFormula)
			return this.link != undefined ? this.link : null;
		return this.link != undefined ? this.link : (this.tmpLink != undefined ? this.tmpLink : null);
	},
	
	/*void*/setDirty:function(dirty) {
		if (dirty == undefined) return;
		
		this._isDirty = dirty;
		if(dirty){
			this._doc._calcManager._addF(this,this.getSheetId());
		}
	},
	
	
	/*boolean*/isDirty:function() {
		return this._isDirty != undefined ? this._isDirty : false;
	},
	
	//return true means that there exist circular
	//but not means that this current cell must be Err522!
	//because the current cell might ignore recursive error
	//IMPORTANT: SHOULD NOT CALL IT DIRECTLY, BECAUSE SOME CELL MIGHT NEED CALL _CheckCRAfterCalc
	//SO IF NEED CHECKCR, WE SHOULD CALL _calculate
	_checkCR:function()
	{
		delete this._bCheckCR;
		if(this.isFormula() && !this.isCR)
		{
			var result = {};
			this.checkCircular(result, /* check-cr result cache */ {});
			//the current cell might be in the circular or out of the circular
			//if has circular, result.baseCell.count > 0
			if(result.baseCell.count > 0)
			{
				{
					var pcm = this._doc._mhelper.getPartialCalcManager();
					//first check the current cell, because this cell might be set a new value
					//which will impact other cells
					if(this._errProp & websheet.Constant.CellErrProp.IGNORE_RECURSIVE){
						this._updateToken = true;
						this._calculate(true);
						delete this._updateToken;
						pcm._collectRows(this);//need update row if the cell has been calculated after it has been rendered
					}
					
					var recalcCellArr = [];
					for(var id in result.recalcCell){
						var cell = result.recalcCell[id];
						recalcCellArr.push(cell);
					}
					//after checkCircular, only cells that out of the circular are exist in recalcCell stack
					//which need to recalculate
					//and only recalculate them when loading
					//when send notify event for set cell, the impact cells of result.changeCells will contain
					//the cells in result.recalcCell.
					var recErr = websheet.Constant.ERRORCODE["522"];
					if(result.changeCell.count){
						var rCells = result.changeCell.toArray();
						var length = rCells.length;
						for(var i=0; i<length; i++){
							var rCell = rCells[i];
							if(rCell._errProp & websheet.Constant.CellErrProp.IGNORE_RECURSIVE){
								var oldV = rCell._calculatedValue;
								rCell._updateToken = true;
								rCell._calculate(true);
								delete rCell._updateToken;
								var newV = rCell._calculatedValue;
								if(oldV !== newV || rCell._error != recErr){
									//recalc all the changeCell
									for(var j=i-1; j>=0; j--){
										var cCell = rCells[j];
										cCell._updateToken = true;
										cCell._calculate(true);
										//recalc the formula but the value is still err522 
										//it might because that it refered cell has not been recalculated
										//so should add it to result.recalcCell
										if(cCell._error == recErr){
											result.recalcCell[cCell._uniqueId] = cCell;
											recalcCellArr.push(cCell);
										}
										delete cCell._updateToken;
										pcm._collectRows(cCell);//need update row if the cell has been calculated after it has been rendered
									}
									for(var j=length-1; j>i; j--){
										var cCell = rCells[j];
										cCell._updateToken = true;
										cCell._calculate(true);
										//if recalc it and the value is still err522 and it ignore recursive error
										//it might because that it refered cell has not been recalculated
										if(cCell._error == recErr){
											result.recalcCell[cCell._uniqueId] = cCell;
											recalcCellArr.push(cCell);
										}
										delete cCell._updateToken;
										pcm._collectRows(cCell);//need update row if the cell has been calculated after it has been rendered
									}
									break;
								}
							}
						}
						//if no cell has been recalc, it means they all #Err522!
						//but they might be set dirty when getImpactCells, so here clear it
						//because it does not need to calc again
						for(var i=0; i<length; i++){
							var rCell = rCells[i];
							delete rCell._isDirty;
							if((rCell._error == recErr) && ( (rCell._errProp & websheet.Constant.CellErrProp.UPDATE_ALWAYS) > 0
									|| (rCell._errProp & websheet.Constant.CellErrProp.NOTIFY_ALWAYS) > 0) ){//for indirect,hlookup formula, the #Err522 might be invalid
								rCell._updateToken = true;
								rCell._calculate(true);
								delete rCell._updateToken;
							}
						}
					}
					//the cell in recalcCell might refer to each other, 
					//only if the later cell has been calculate, the previous cell can get the correct value
					//so we should loop it until no cell can be calc in one loop(they must all be #Err522!)
					//or there is no cell in result.recalcCell
					var hasCalc = true;
					var bToggle = false;
					var length = recalcCellArr.length;
					while(hasCalc){
						hasCalc = false;
						for(var i = 0; i<length; i++){
							var j = i;
							if(bToggle)
								j = length - i - 1;
							var cell = recalcCellArr[j];
							//if cell not in recalcCell map means that it has already been calculated
							if(!result.recalcCell[cell._uniqueId])
								continue;
							var oldV = cell._calculatedValue;
							cell._updateToken = true;
							cell._calculate(true);
							delete cell._updateToken;
							var newV = cell._calculatedValue;
							if(oldV != newV){
								hasCalc = true;
								if(newV != recErr)
									delete result.recalcCell[cell._uniqueId];
								pcm._collectRows(cell);//need update row if the cell has been calculated after it has been rendered
							}
						}
						bToggle = !bToggle;
					}
				}
				return true;
			}
		}
		return false;
	},
	
	_calculate: function(){
		delete this._isDirty;
		if (this._bUpdateFormula) {
			var ret = this.regenerateFormula();
			if (ret === true) {
				//TODO: test =counta(#REF!)
				// only if we meet boolean true, means regenerateFormula meets #REF!, end early
				delete this._isUnCalc;
				return;
			}
		}
		var tokenTree = null;
		var calcParams = {};
		
		if(!this.isParsed){
			if(!this.isFormula()){
				this.isParsed = true;
				this._setFormatType(this._rawValue);
				return;
			}
			// it might contains tokenArray which is set by tarr, we should clear it first
			if(this._bUpdateFormula){
				var oldValue = this._rawValue;
				this._rawValue = this.updateFormula();
			}
			this.clearRefs();
			
			var af = null;
			var currentTask = this._doc._taskMgr._current;
			if(currentTask){
				var scope = currentTask.scope;
				if(scope && scope.getAutofillFormulas){
					sId = currentTask.args[0];
					af = scope.getAutofillFormulas(sId);
				}
			}
			if(!af){
				var pcm = this._doc._mhelper.getPartialCalcManager();
				af = pcm.getAutofillFormulas();
			}
			var predictResult = websheet.parse.FormulaParseHelper.predictFormula(this, af);
			if(!this.isParsed){
				var e = predictResult.error;
				if(!e){
					var lexemes = predictResult.lexemes;
					if(lexemes){
						var pResult = websheet.parse.FormulaParseHelper.parseFormula(lexemes, true, this);
						e = pResult.error;
						tokenTree = pResult.tokenTree;
					}
				}
				if(e){
					this.isParsed = true;
					delete this._isUnCalc;
					//"#ERROR!" user input formula which contains syntax error in the old version
					this._error = websheet.Constant.ERRORCODE["1002"];
					var value = this._error.message;
					this.setCalculatedValue(value);
					this._setFormatType(value, true);
					delete this._showValue;
					this._onCalComplete();
					return;
				}
				this._isUnCalc = true;
			} else {
				// predict as the autofill formula
				tokenTree = this.getCellToken();
			}
			
		} else if(this.getCellToken() != null){
			if(this._bCheckCR){
				//incase when checkcr there are impact cells also need refer to this cell
				this._isUnCalc = true;
				var hasCR = this._checkCR();
				//the current cell must call _calculate(true) again in _checkCR
				if(hasCR)
					return;
			}
			
			tokenTree = this.getCellToken();
			
			if( this._isUnCalc    // calc once by partial calc manager, so it need recalc all the token tree
					|| this._updateToken)//set when need checkCR because checkCR might happens when cell has been set dirty and set limited token update
			{
				calcParams.bUpdateAll = true;//calc all the token tree
			}
		}
		
		if(this._bAfPat){
			calcParams.bAutofill = true;
			calcParams.bUpdateAll = true;
			calcParams.tokenArray = this._tokenArray;
		}
		
		var result = websheet.parse.FormulaParseHelper.calcFormula(this, tokenTree, calcParams);
		if(result.error)
			this._error = result.error;
		else
			this._error = null;
		
		var value = result.value;
		this.setCalculatedValue(value);
		this._setFormatType(value, true);
		
		this._onCalComplete();
		
		delete this._showValue;
	},
	
	_onCalComplete: function(){
		if(this.calComplete){
			if(this._isUnCalc){
				if(!this._calcing){
					this._calcing = true;
					websheet.model.ModelHelper.getPartialCalcManager().calcVisibleFormula();
				}
			}
			else{
				this.calComplete();
				delete this.calComplete;
				delete this._calcing;
			}
		}
	},
	
	/*
	 * set cell type and format, update calculated value with type fixed value
	 */
	_setFormatType:function(value, isFormula)
	{
		delete this._format;
		if (isFormula) {
			// need to determine the format type and currency for formula
			// check whether the formula has any associated format type with which the formula result is formatted 
			var token = this._tokens;
			// this._bInheritFormat is TRUE when user inputs one formula		
			if (this._bInheritFormat && token) {
				try {
					var result = token.getFormat();
					if(!result && this._isPercent){
						var formatType = websheet.Constant.FormatType["PERCENT"];
						result = websheet.i18n.Number.getDefaultFormatForShowValue(formatType);						
						delete this._isPercent;
					}
					if(result)
						this._format = result;
				} catch (e) {
					console.log(e);
				}
			}
			
			// parse cell type, for formula, don't turn numeric string calculated value to number 
			this._type = this._doc._mhelper.getCellType(this._rawValue, value, true);
			if (this._type >> 3 == this.ValueCellType.ERROR && this._error == null) {
				// if we guess the cell is error type, but no _error is set during formula calculation, we
				// correct our guess to string
				this._type = (this.ValueCellType.STRING << 3) | this._type & this.ValueCellType.FORMULA_TYPE_MASK;  
			}
			this.setCalculatedValue(this._doc._mhelper.fixValueByType(value, this._type));
		} else {
			this._type = this._doc._mhelper.getCellType(value);
			this.setCalculatedValue(this._doc._mhelper.fixValueByType(value, this._type));
		}
	},

	/*
	 * if this._bCheckCR is true, will call this._checkCR() to tell whether this.isCR is true or not
	 */
	/*void*/setCheckCR: function(/*boolean*/bCheckCR) {
		this._bCheckCR = bCheckCR; 
		delete this.isCR;//set cell bCheckCR=true, then call _checkCR, isCR will be set true to all the circular cells, which do not need _checkCR again
	},
	
	/*boolean*/checkCircular:function(result, resultCache) {
		var pcm = this._doc._mhelper.getPartialCalcManager();
		var isCircular = false;
		//record all the cell which need check recursive
		if(!result.stack)
			result.stack = {};
		//record the first recursive cell
		if(!result.baseCell)
			result.baseCell = new dojox.collections.Stack();
		//record all the recursive cell
		//means that the cell has change the calculate value to #Err522!
		if(!result.changeCell){
			result.changeCell = new dojox.collections.Stack();
			result.changeCellIds = {};
		}
		//record all the cells that need to be recalculate
		//when result.baseCell is not empty
		//means there has circular, so these cells should be recalc
		if(!result.recalcCell)
			result.recalcCell = {};
		//here do not care the formula is ignore recursive or not
		//because =row(B8) + B1 might also return #Err522! if recusive with B1
//		if(!(this._errProp & websheet.Constant.CellErrProp.IGNORE_RECURSIVE))
		{
			result.stack[this._uniqueId] = this;
			var cells = this._getImpactCells();
			this.isCR = true;
			for(var i=0; i<cells.length;i++)
			{
				var cell = cells[i];
				if(cell && cell.isFormula() )
				{
					if(result.stack[cell._uniqueId])
					{
						result.baseCell.push(cell);
						delete result.stack[cell._uniqueId];
						if(!result.changeCellIds[cell._uniqueId]){
							result.changeCellIds[cell._uniqueId] = cell;
							result.changeCell.push(cell);
						}
						cell.setError(websheet.Constant.ERRORCODE["522"]);
						resultCache[cell._uniqueId] = true;
						if(!this._doc.isDeepParsing)
						{
							delete cell._isUnCalc;
							delete this._isDirty;
							pcm._collectRows(cell);//need update row if the cell has been calculated after it has been rendered
						}
						isCircular = true;
					}else
					{
						var v = resultCache[cell._uniqueId];
						if (v == null) {
							v = cell.checkCircular(result, resultCache);
							resultCache[cell._uniqueId] = v;
						}
						if(v){
							if(!result.changeCellIds[cell._uniqueId]){
								result.changeCellIds[cell._uniqueId] = cell;
								result.changeCell.push(cell);
							}
							delete result.stack[cell._uniqueId];
							cell.setError(websheet.Constant.ERRORCODE["522"]);
							resultCache[cell._uniqueId] = true;
							if(!this._doc.isDeepParsing)
							{
								delete cell._isUnCalc;
								delete this._isDirty;
								pcm._collectRows(cell);//need update row if the cell has been calculated after it has been rendered
							}
							isCircular = true;
						}
					}
				}
			}
			if(!isCircular){
				delete result.stack[this._uniqueId];
				result.recalcCell[this._uniqueId] = this;
			}
		}
		return isCircular;
	},
	
	/**
	 *get the formula cells which refer to the cell
	 */
	_getImpactCells:function()
	{
		var type = websheet.Constant.EventType.DataChange;
		var source = {action:websheet.Constant.DataChange.SET,
				refType: websheet.Constant.OPType.CELL};
		var sheetName = this._parent._parent.getSheetName();
		var r = this.getRow();
		var c = this.getCol();
		source.refValue = new websheet.parse.ParsedRef(sheetName, r, c, r, c, websheet.Constant.RANGE_MASK);
		var e = new websheet.listener.NotifyEvent(type, source);
		return this._doc.getAreaManager().getImpactCells(e);
	},
	
	/**
	 * reset cell attributes to default,which relate to value
	 * bKeepLink: indicate whether the link and _hasLink attributes should be kept intact
	 */
	/*void*/reset:function(bKeepLink){
		this._rawValue = "";
		this._calculatedValue = "";
		this._error = null;
		this._type = null;
		delete this._tokens;
		delete this._tokenJson;
		this.isParsed = false;
		delete this._isUnCalc;
		delete this.isCR;
		delete this._bCheckCR;
		delete this._format;
		if(!bKeepLink) {
			delete this._hasLink;
			delete this.link;
		}
		delete this._hasURL;
		delete this.tmpLink;
		delete this._showValue;
		delete this._isDirty;
		delete this._bUpdateFormula;
		this._errProp = websheet.Constant.CellErrProp.DEFAULT;
		this.clearRefs();
		delete this._bAfPat;
		delete this._styleId; // workaround here to delete unused styleId
		delete this._colSpan;
		delete this._rowSpan;
		delete this._isCovered;
	},
	
	setErrProp:function(prop)
	{
		this._errProp |= prop;
	},
	
	/*boolean*/getUpdateFormula:function()
	{
		return this._bUpdateFormula != undefined ? this._bUpdateFormula : false;
	},
	
	/**
	 * <p>
	 * regenerate cell's formula string if bUpdateFormula is true or it need get locale sensitive formula
	 * reset bUpdateFormula to false after cell token is serialized
	 * <p>
	 * Returns:
	 * 	number | string : the rawValue
	 * 	boolean: true if the generation reports an "524" error
	 * 	null: other (can't tell clearly...) cases.
	 */
	/*void*/regenerateFormula:function(bLocaleSensitive){
		//if the formula parameter is seperated by comma ",",
		//there might be no cell token list for this cell.
		if(this.getCellToken())
		{
			var rawValue = this._rawValue;
			var result = {};
			if (this._bUpdateFormula || bLocaleSensitive) {
				try{
					result = this.getCellToken().serialize(this, bLocaleSensitive);
				} catch(e) {
					// too much recursion error which is caused by too deep call stack
					// LIMITATION: if it is bLocaleSnesitive with non enlish locale, it might return the wrong value
					this._rawValue = this.updateFormula();
					return this._rawValue;
				}
				if(result.isArrayFormular){
					rawValue = "={" + result.rawValue + "}";
				}else{
					rawValue = "=" + result.rawValue;
				}
				if (this._bUpdateFormula)
					delete this._bUpdateFormula;
			}
			if(bLocaleSensitive)
				return rawValue;
			else{
				this._rawValue = rawValue;
			}
			if(result.isError){
				this.setError(websheet.Constant.ERRORCODE["524"]);
				this.setLink(null);
				return true;
			}
		}else{
			if(!this.isParsed && this._bUpdateFormula){
				this._rawValue = this.updateFormula();
			}
			return this._rawValue;
		}
	},
		 
	 /**
	 * take value, style, etc from provided cell json
	 */
	/*void*/setCellByJson: function(cellJson,colStyleId,bReplace, mode)
	{
		var bUndoRedo = ((mode != websheet.Constant.MSGMode.NORMAL) && (mode != undefined));
		// set cell value
		
		var rawValue = cellJson.v;
		if(rawValue === undefined) 
			rawValue = "";
		if (bReplace)
		{
			this.setRawValue(rawValue, true, true);
			if (cellJson.tarr) {
				this.setReferences(cellJson.tarr);
			}
			// need to set link here because this cell, and cellJson may include or not include link
			// so if raw value is not empty, should use cellJosn's link to override the link value in cell
			if (rawValue) {
				this.setLink(cellJson.link, true);				
			}
			
			// FIXME how to set link when import csv data where the link isn't available but bReplace is true?
		}
		else
		{
			// when paste data from external application, the link will be kept if cell to be pasted has new non-empty value
		    //rawValue ==="", means clear the data and keep the style
			if (rawValue ==="" || !this._doc._mhelper.isEmpty(rawValue))
			{
				this.setRawValue(rawValue, true, bUndoRedo);
			}
			if (cellJson.tarr) {
				this.setReferences(cellJson.tarr);
			}
		}
		if( this.isFormula()){
			if(!this._doc.isLoading) {
				//when call setRawValue it must triggerred by set the cell/range event and it need to append to formula track
				this._doc.getAreaManager().appendToFormulaTrack(this);
			}
			if(!bUndoRedo)
				this._needPartial = true;
		}
		
	},
	
	/**
	 * set cell's raw value
	 * @param rawValue
	 * @param isNotCalculate		true:not calculate value
	 * 								false:calculate value
	 * @param bNotSetLink			true if need to use regular expression to check whether it is one hyperlink
	 */
	/*void*/setRawValue:function(rawValue, isNotCalculate, bNotSetLink){
		//clear variables relate to cell value
		var bKeepLink = this.link != undefined ? true : false;//don't keep the link set by hyperlink formula.
		if(rawValue === "" || rawValue === null)
			bKeepLink = false;
		this.reset(bKeepLink);
		//split cell
		var sheetId = this._parent._parent._id;
		// store raw value	
		this._rawValue = rawValue;
		// refresh cell type
		this._type = this._doc._mhelper.getCellType(rawValue, null);
		var bFormula = this.isFormula();
		if(bFormula){
			this._uniqueId = this._parent._parent._id + "." + this._id + this._parent._id;
		} else {
			// if not formula, fix raw value according to type
			rawValue = this._rawValue = this._doc._mhelper.fixValueByType(rawValue, this._type);
			// special case when it is error type, set _error to the error code object
			if (this._type >> 3 == this.ValueCellType.ERROR) {
				this._error = this._doc._mhelper.toErrCode(rawValue);
			}
		}
		
		//if it is formula, add to formula cells, else remove it if the original value is formula
		this._doc._calcManager.updateFormulaCell(this, bFormula);
		if(!bNotSetLink && !this._hasLink && !bFormula){
			this.setLink(rawValue);
		}
		this._calculatedValue = this.escapeSingleQuote(rawValue);
		//calculate raw value to get the calculated value
		if (!isNotCalculate) {
			if (this._doc.isLoading && bFormula)
				// if setRawValue during loading, we can't _calculate() at this time since all referenced cells may not
				// ready yet, push to parse queue to calculate after model is ready
				;
			else
				this._calculate();
		} else {
			if (!bFormula) {
				// if not formula, mark "parsed", since probably no chance to get _parse() called and set isParsed on this cell in the future 
				this.isParsed = true;
			} else
				this._isUnCalc = true;
		}
	},
	
	/**
	 * get cell's raw value
	 */
	/*string*/getRawValue:function(){
		// re-serialize formula
		if (this._bUpdateFormula)
			this.regenerateFormula();
		
		return this._rawValue;
	},
	
	/**
	 * set cell's calculated value
	 */
	/*void*/setCalculatedValue: function(calculatedValue) {
//		if(this._calculatedValue && this._calculatedValue !== calculatedValue && calculatedValue != this._rawValue && this._calculatedValue !== this._rawValue){
//			console.log(this.getAddress() + " calc wrong");
//		}
		this._calculatedValue = calculatedValue;
	},
	
	/**
	 *  check a formula cell's status 
	 */
	/*Boolean*/isCalculated: function() {
		return !this._isDirty && !this._isUnCalc && this.isParsed;
	},
	/**
	 * get cell's calculated value
	 */
	/*string*/getCalculatedValue: function() {
	  if (this._isDirty && !this._isUnCalc) {
			this._calculate();
		}
		return this._calculatedValue;
	},
		
	/**
	 * !!!DON'T CHANGE CELL OBJECT HERE, THE CELL OBJECT IS ONE MIXED CELL OBJECT
	 * @param styleId	column style id
	 * get cell's editable value
	 */
	/*string*/getEditValue: function(/*string*/styleId, ignoreProtect) {
		if(!ignoreProtect && this._parent._parent._bProtected){
			var colStyleId = styleId;
			if(!colStyleId){
				var colIndex = this.getCol();
				var column = this._parent._parent.getColumn(colIndex, true);
				colStyleId = column && column.getStyleId();
			}
			if(this.isHidden(colStyleId))
				return "";
		}
		var editValue = this.getRawValue();		
		if (this.isFormula()) {
			if(this.getCellToken()){
				editValue = this.regenerateFormula(true);//bLocaleSensive
			}else{
				editValue = this._rawValue;
			}
			return editValue;
		}
		
		var valueType = this._type >> 3;
		var numFmt = websheet.i18n.Number;
		switch (valueType) {
		case this.ValueCellType.NUMBER:
			var editValue = this._calculatedValue;
			var colStyleId = styleId;
			if(!colStyleId){
				var colIndex = this.getCol();
				var column = this._parent._parent.getColumn(colIndex, true);
				colStyleId = column && column.getStyleId();
			}
			var style = this.getStyle(colStyleId);
			var format = websheet.Helper.getFormat(style);
			var formatType = websheet.Constant.FormatType["NUMBER"];
			var isSci = websheet.Helper.isSciNum4EditValue(editValue);
			if(isSci)
				formatType = websheet.Constant.FormatType["SCIENTIFIC"];
			if (format) {
				var type = numFmt.getFormatTypeByValue(this._rawValue, format);
			    if(!isSci){			    
			 		if (type == websheet.Constant.FormatType["SCIENTIFIC"])
						formatType = websheet.Constant.FormatType["NUMBER"];
					else
						formatType = type;
				}				
			}
			
			format = numFmt.getDefaultFormatForEditValue(formatType, this._calculatedValue);		
			return numFmt.format(editValue, format, this._type >> 3, true);
		case this.ValueCellType.BOOLEAN:
			// nothing to format but show boolean string in nls
			return numFmt.format(editValue, null, valueType);
		default:
			return editValue;
		}
	},
	
	/*
	 * !!!DON'T CHANGE CELL OBJECT HERE, THE CELL OBJECT IS ONE MIXED CELL OBJECT
	 * 
	 * get cell's show value for grid rendering
	 * 
	 * @param styleId		style cell's styleId or column style id
	 * @param forceUseStyle      use styleId to force format number
	 * TODO format with cell's _rawValue instead if displaying formula string on grid needs to be supported
	 */
	/*string*/getShowValue: function(/*string*/styleId, forceUseStyle) {
		var showValue = this.getCalculatedValue();
		if (this.isUnknown() || this._error) return showValue;
		if (typeof showValue == "string" && showValue.length == 0) return showValue; // probably it is one mixed cell
		// use the cached _showValue
		if (this._showValue != undefined && !forceUseStyle) return this._showValue;

		// format style has higher priority than _formatType
		var format, style;	
		//this._styleId might not be latest, because it is not always mixin with the style cell
		if(styleId)
			style = this._doc._styleManager.styleMap[styleId];

		var ws = websheet;
		format = ws.Helper.getFormat(style, forceUseStyle);
		var numFmt = ws.i18n.Number;
		if ((this._type >> 3) == this.ValueCellType.BOOLEAN) {
			// format value when it is boolean, only need to apply formatting if format category is text
			if (format && format[ws.Constant.Style.FORMATTYPE] == "text") {
				showValue = numFmt.format(showValue, format, this._type >> 3);
			} else {
				// just format to boolean string
				showValue = numFmt.formatBoolean(showValue);
			}
		} else if (format != null) {
			// need format if has any format code set
			if ((this._type >> 3) == this.ValueCellType.NUMBER || // apply format when cell is number
					(format[ws.Constant.Style.FORMATTYPE].indexOf("text") > -1)) {	// or apply format when format category is "text" or "number;number;number;text"
				showValue = numFmt.format(showValue, format, this._type >> 3);
			}
			// else, cell is not boolean, cell is not number, customized format is not text,
			// don't apply the format and leave show string as-is
		} else if ((this._type >> 3) == this.ValueCellType.NUMBER) {
			// default format if it is number and no customized format provided
			showValue = numFmt.generalFormatNumber(showValue);
		}
		// else, it is error, or text, and no format is set, nothing left to do
		
		// use less memory for IE
		if (!forceUseStyle && (format || !dojo.isIE))
			this._showValue = showValue;

		return showValue;
	},
	
	/**
	 * set cell type (Normal,formula,arrayFormula)
	 */
	/*void*/setType:function(type){
		this._type = type;
	},
	/**
	 * return cell type (Normal,formula,arrayFormula)
	 */
	/*integer*/getType:function(){
		return this._type;
	},
	/**
	 * set cell's token tree
	 */
	/*void*/setCellToken:function(tokens){
		this._tokens = tokens;
		this.isParsed = true;
	},
	/**
	 * get cell's token tree
	 */
	/*Token*/getCellToken:function(){
		return this._tokens;
	},
	
	/**
	 * set user id who edit this cell
	 */
	/*void*/setUser:function(userId){
		this._userId = userId;
	},
	/**
	 * remove user
	 */
	/*void*/removeUser:function(){
		delete this._userId;
	},
	/**
	 * get user id
	 */
	/*string*/getUser:function(){
		return this._userId;
	},
	
	_getNumber: function(value){
		var tmpCalValue = parseFloat(value);
		//var absCalValue = Math.abs(tmpCalValue);
		//if(absCalValue == 0 || !(absCalValue <= websheet.Constant.SCMinValue || absCalValue >= websheet.Constant.SCMaxValue))			
		if(!isNaN(tmpCalValue) && isFinite(tmpCalValue)) 
			return tmpCalValue;
		return null;
	},
	
	/**
	 * construct the tokenList for cell/range references
	 * which is used to update the formula string if the cell is unparsed and user insert/delete row/column/sheet
	 * @param cellRef When load content from, it is the cell reference in reference.js,
	 * 				  in other condition, it is a two-dimensional array
	 * cellRef is an array with the order of the reference index
	 * @param mode if it is normal msg, set reference to trigger partial load when get cells of this reference
	 */
	setReferences:function(cellRef)
	{
		try{
			if(cellRef){
				if(this._doc.isLoading){
					// do not need reference.js of impact cells from server side,
					// but parse the formula by self
					var pResult = websheet.parse.FormulaParseHelper.parseFormula(this._rawValue, false, this);
					var e = pResult.error;
					var tokenTree = pResult.tokenTree;
				}else{
					this.deserializeTokenArray(cellRef);
				}
			}
		}catch(e){
			console.log("set references error for cell " + this._uniqueId);
		}
	},
	
	/**
	 * update formula(rawValue in ods format) according to _tokenArray
	 * when cell is not parsed
	 * the token index also be updated if the reference address changed
	 * @returns
	 */
	updateFormula:function()
	{
		if(!this._tokenArray || this._tokenArray.length == 0) 
			return this._rawValue;
		var result = "";
		var start = 0;
		var size = this._tokenArray.length;
		for(var i=0; i<size; i++){
			var token = this._tokenArray[i];
			var range = token.getValue();
			if(!(range instanceof websheet.parse.Reference))
				continue;
			//name range will never change the token text
			if(range.getUsage() == websheet.Constant.RangeUsage.NAME)
				continue;
			var oriText = token.getName();//original cell/range text
			var length =  oriText.length;
			var end = token.getIndex();
	        var tmpStr = this._rawValue.substring(start,end);
        	result += tmpStr;
			var newText = token.getAddress();
			token.setName(newText);
			token.setIndex(result.length);
        	result += newText;
        	start = end + length;
		}
		var lastStr = this._rawValue.substring(start,this._rawValue.length);
        result += lastStr;
        
        delete this._bUpdateFormula;
        return result;
	},
	
	/**
	 * serialize tokenArray into an two-dimensional array
	 * each array represent the position of each reference by order.
	 * it include the range/cell token start index and end index of the rawValue
	 */
	//bNotUpdateFormula=true, means get the old token array before update formula
	//which is used by collect formula cell for delete undo event 
	serializeTokenArray:function(bNotUpdateFormula){
		if(!bNotUpdateFormula && this._bUpdateFormula)
			this.regenerateFormula();
		if(!this._tokenArray || this._tokenArray.length == 0) 
			return null;
		var arr = [];
		var size = this._tokenArray.length;
		var tokenArr = this._tokenArray;
		for(var i=0; i<size; i++){
			var token = tokenArr[i];
			var text = token.getName();
			var index = token.getIndex();
			var endIndex = index + text.length;
			arr.push([index, endIndex]);
		}
		return arr;
	},
	
	/**
	 * deserialize the two-dimensional array into tokenArray
	 */
	deserializeTokenArray:function(arr){
		if(arr){
			this._tokenArray = [];
			var parseHelper=websheet.parse.FormulaParseHelper;
			var sheetName = this.getSheetName();
			var size = arr.length;
			for(var i=0; i<size; i++){
				var t = arr[i];
				var index = t[0];
				var endIndex = t[1];
				if(index < 0)
					continue;
				var addr = this._rawValue.substring(index, endIndex);
				var token = parseHelper.generateTokenByAddress(addr, this);//#REF! has been generated as error token, rather than refToken
				if(token && token.setIndex){
					token.setIndex(index);
				}
			}
		}
	},
	
	/**
	 * push the rawTokenArray which is parsed by FormulaParser
	 * @param rawTokenArray
	 */
	pushTokenArray: function(rawTokenArray){
		if(rawTokenArray){
			var tokenType = websheet.parse.tokenType;
			var HELPER = websheet.parse.FormulaParseHelper;
			var length = rawTokenArray.length;
			for(var i = 0; i < length; i++){
				var token = rawTokenArray[i];
				if(token.getType() == tokenType.NAME)
					HELPER.pushRawNameToken(token, this);
				else
					HELPER.pushRawRefToken(token, this, true);//check if token is invalid 3D reference
			}
		}
	},
	
	//////////////////////////////////////////////////////////////////////////
	/////////// THE LISTENER OF REFERENCE ////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	/*void*/notify: function(/*broadcaster*/area, event) {
		//set dirty when set cell, and set formula update when delete/insert
		var constant = websheet.Constant;
		if(event._type == constant.EventType.DataChange) {
			var source = event._source;
			var action = source.action;
			var refType = source.refType;
			var refValue = source.refValue;
//			var bNameArea = area instanceof websheet.parse.NameArea;// false for undefinedname
//			var areaValue = bNameArea ? {id: area.getId(), area: area} : null;
			var isDirty = false;
			var bUpdateToken = true;
			
			if (action == constant.DataChange.SET
				&& (refType == constant.OPType.RANGE || refType == constant.OPType.CELL) ) { // set cell event will be sent by _getImpactCells
					var id = area.getId().toLowerCase();
					this.iterateRefTokens(id, area, function(token){
						var props = token.getProps();
						if( (props & websheet.Constant.RefType.IGNORESET) == 0){
							isDirty = true;
							token.setUpdate(true);
						}
					});
			} else if (refType == constant.OPType.AREA) {
			    isDirty = true;
				bNameArea = true;
				switch(action) {
					case constant.DataChange.INSERT:
					case constant.DataChange.DELETE:{
						var newArea = refValue;
						isDirty = true;
						var oldArea = area;
						var mask = constant.RANGE_MASK;
						var bEnableName = false;
						if(action == constant.DataChange.INSERT){
							mask = newArea.getMask();
							bEnableName = true;
						}
						var id = newArea.getId().toLowerCase();
						this.iterateRefTokens(id, oldArea, function(token){
							token.setValue(newArea);
							token.setUpdate(true, {enableNameRange:bEnableName});
							if(action == constant.DataChange.INSERT){
								delete token._error;
								if(!newArea.isValid())
									token.setError(websheet.Constant.ERRORCODE["524"]);
							} else {
								//delete
								token.setError(websheet.Constant.ERRORCODE["525"]);
							}
						});
						break;	
					}
					case constant.DataChange.SET: {
						// refValue for set area event is the non-updated parsedRef, area is the updated area
						isDirty = true;
						var id = area.getId().toLowerCase();
						var isValid = area.isValid();
						this.iterateRefTokens(id, area, function(token){
							token.setUpdate(true);
							if(!isValid)
								token.setError(websheet.Constant.ERRORCODE["524"]);
							else
								delete token._error;
							token.setRefMask(refValue.refMask);
						});
						break;
					}
					default:
						break;
				}
			} else if (refType == constant.OPType.SHEET) {
				var sheetName = refValue;
				// for predelete sheet event, set dirty and update formula flag for cells which are not in this delete sheet
				if(action == constant.DataChange.PREDELETE) { // predelete sheet
					var data = source.data;
					if(sheetName != this.getSheetName()) {
						// need to reset update formula again for the real delete sheet action 
						// when the cell gets showvalue to update the formula.
						// except for 3D reference which delete the sheet which is neither start sheet nor end sheet
						if(!(data && data.b3DRef && data.addressNotChanged)) {
							this._doc.getAreaManager()._addCell4DeleteUndo(this);
							this._bUpdateFormula = true;
						}
						isDirty = true;
						var id = area.getId().toLowerCase();
						this.iterateRefTokens(id, area, function(token){
							if(!data.b3DRef)
								token.setRefMask(constant.RefAddressType.INVALID_SHEET, true);
							token.setUpdate(true);
						});
					} else if (data && data.b3DRef) {
						// the cell contains 3D ref and locate in delete sheet
						// it can not be collected as set cell event when undo
						// so the 3D ref's delete sheet name can not be recovered
						// while the cell's raw value is right, 
						// so set it unparsed to trigger it recalculate and remove the original(wrong) 3D ref
						this.isParsed = false;
					}
				} else if (action == constant.DataChange.SET) { // rename sheet
					var self = this;
					var newSheetName = source.newSheetName;
					var oldSheetName = source.oldSheetName;
					this.iterateRefTokens(null, null, function(token, bInTokenTree){
						var props = token.getProps();
						if ( (props & websheet.Constant.RefType.CAREPOSITION) > 0 ){
							token.setUpdate(true, {positionChanged:true});//positionchanged for updateRefToken
							isDirty = true;
						}
						
						if (token.getRefMask() & constant.RefAddressType.SHEET > 0) {
							var ref = token.getValue();
							// ref now has not  change the name yet
							if (bInTokenTree && ref && (ref.getSheetName() == oldSheetName || ref.getEndSheetName() == oldSheetName) ){
								self._bUpdateFormula = true;
								if((self._errProp & websheet.Constant.CellErrProp.UPDATE_ALWAYS) > 0){
									token.setUpdate(true);
									isDirty = true;
								}
								return true;
							}
						}
					});
				} else if (action == constant.DataChange.INSERT) { // insert sheet
					var data = source.data;
					if(data && data.b3DRef && data.bDirty) {
						isDirty = true;
						var id = area.getId().toLowerCase();
						this.iterateRefTokens(id, area, function(token){
							token.setUpdate(true);
						});
					}
				} 
				else if (action == constant.DataChange.PREMOVE) { // move sheet
					var data = source.data;
					if(data && data.b3DRef) {
						isDirty = data.bDirty;
						if(!data.addressNotChanged) {
							this._doc.getAreaManager()._addCell4DeleteUndo(this);
							this._bUpdateFormula = true;
						}
						var id = area.getId().toLowerCase();
						this.iterateRefTokens(id, area, function(token){
							token.setUpdate(true);
						});
					}
				}
			} else if ((action == constant.DataChange.PREINSERT || action == constant.DataChange.PREDELETE)) {
				if (refType == constant.OPType.ROW || refType == constant.OPType.COLUMN) {
					var data = source.data;
					if (action == constant.DataChange.PREDELETE) {
						if (data && data.collectUndo) {
							this._doc.getAreaManager()._addCell4DeleteUndo(this);
						} else {
							this._doc.getAreaManager()._prepareCell4DeleteUndo(this);
						}
					}
					var sizeChanged = data && data.sizeChanged;
					var self = this;
					var id = area.getId().toLowerCase();
					this.iterateRefTokens(id, area, function(token, bInTokenTree){
						var props = token.getProps();
						if( (sizeChanged && ( (props & websheet.Constant.RefType.IGNORESET) == 0 || (props & websheet.Constant.RefType.ONLY_CARESIZE) == 0 ))
								|| ((props & websheet.Constant.RefType.CAREPOSITION) > 0) ){
							token.setUpdate(true, {positionChanged:true});//positionchanged for updateRefToken
							isDirty = true;
						}
						//for update token ,do not set update formula
						// but for name token, it need updateFormula to check if the updated parsed ref is valid or not
						if (!self._bUpdateFormula && bInTokenTree)
							self._bUpdateFormula = true;
					});
				}
			} else if (action == constant.DataChange.SHOW || action == constant.DataChange.HIDE) {
				var id = area.getId().toLowerCase();
				this.iterateRefTokens(id, area, function(token){
					var props = token.getProps();
					if( (props & websheet.Constant.RefType.CARESHOWHIDE) > 0){
						isDirty = true;
						token.setUpdate(true);
					}
				});
			} else if (action == constant.DataChange.FILTER) {
				var id = area.getId().toLowerCase();
				this.iterateRefTokens(id, area, function(token){
					var props = token.getProps();
					if( (props & websheet.Constant.RefType.CAREFILTER) > 0){
						isDirty = true;
						token.setUpdate(true);
					}
				});
			} else if (action == constant.DataChange.CUT ) {
				var cellInCutArea = this._isCellInCutArea(refValue);
				//Only collect the cell to cut update if it is not in cut area.
				if(!cellInCutArea)
					this._doc.getAreaManager()._addCell4DeleteUndo(this);
				
				var id = area.getId().toLowerCase();
				var self = this;
				var data = source.data;
				var sheetDelta = data.sheetDelta;
				this.iterateRefTokens(id, area, function(token, bInTokenTree){
					var props = token.getProps();
					if(!area.cutRef || (props & websheet.Constant.RefType.CAREPOSITION) > 0){
						isDirty = true;
						token.setUpdate(true);
					}
					
					if(bInTokenTree && token.getTokenType() != websheet.parse.tokenType.NAME){
						//_dirtyCut means the formula cell is also cutted and its reference need to be transformed.
						//Use _dirtyCut flag to update the cell JSON for paste.
						if(area.cutRef && !self._dirtyCut)
							self._dirtyCut = cellInCutArea;
						
						if(sheetDelta && ((cellInCutArea && !area.cutRef) || (!cellInCutArea && area.cutRef)))
							token._refMask |= websheet.Constant.RefAddressType.SHEET;
						
						if (!self._bUpdateFormula)
							self._bUpdateFormula = true;
					}
				});
			}
			if (isDirty) {
				this.setDirty(true);
				this._doc.getAreaManager().appendToFormulaTrack(this);
			}
	    }
	 },
	 
	 _isCellInCutArea: function(refValue)
	 {
		 var parsedRef = websheet.Helper.parseRef(refValue);
		 if(parsedRef.sheetName != this.getSheetName())
			 return false;
		 
		 var colIndex = this.getCol();
		 if(colIndex < parsedRef.startCol || colIndex > parsedRef.endCol)
			 return false;
		 
		 var rowIndex = this.getRow();
		 if(rowIndex < parsedRef.startRow || rowIndex > parsedRef.endRow)
			 return false;			 
		 
		 return true;
	 },
	 
	//if callback return true, then stop iteration
	iterateRefTokens:function(areaId, area, callback) {
		try{
		//1. iterate tokenArray
		var length = this._tokenArray.length;
		for(var i = 0; i < length; i++){
			var token = this._tokenArray[i];
			if(!area || token.getValue() == area){
				if (callback(token, true)){
					return;
				}
			}
		}
		//2. iterate updateRefTokens
		if (areaId) {
			var tokenList = this._updateRefTokens[areaId];
			if(tokenList){
				for(var i in tokenList) {
					var token = tokenList[i];
					if (!area || (token.getValue() == area)){
						if (callback(token)){
							return;
						}
					}
				}
			}
		} else {
			var stop = false;
			//iterate every token
			for(var id in this._updateRefTokens){
				var tokenList = this._updateRefTokens[id];
				for (var i in tokenList){
					var token = tokenList[i];
					stop = callback(token);
					if(stop)
						return;
				}
			}
		}
		}catch(e) {
			// it should be internal error for "too much recursion" in FF, or "stack overflow" in IE
			// due to the formula token tree's depth is too large
			console.log("iterateReftoken error :" + e);
		}
	}
});